import streamlit as st
import ja
from langchain_core.messages import HumanMessage
import uuid
import glob
import os
import re
import pandas as pd

st.set_page_config(page_title="Journaling Agent", page_icon="ðŸ“–", layout="wide")

st.title("ðŸ“– Journaling Agent")

# --- Helper Functions ---

def get_journal_entries():
    """Reads all journal markdown files and extracts date, mood, and content for EACH entry."""
    files = glob.glob("journal_*.md")
    files.sort(reverse=True) # Newest first
    
    all_entries = []
    for file in files:
        try:
            with open(file, "r", encoding="utf-8") as f:
                content = f.read()
            
            # Split content by the separator used in ja.py
            # The separator is "\n---\n*Generated by LangGraph Agent*\n"
            # But we can just split by "---" and filter.
            # Better yet, use regex to find each entry block.
            
            # Pattern to match a full entry:
            # # Journal Entry: <date>
            # **Mood:** <mood>
            # ... content ...
            
            # We'll split by the header "# Journal Entry:"
            # Note: The first one might be at the start of the file.
            
            raw_entries = re.split(r'(?=# Journal Entry:)', content)
            
            for raw_entry in raw_entries:
                if not raw_entry.strip():
                    continue
                
                # Extract Date
                date_match = re.search(r"# Journal Entry: (\d{4}-\d{2}-\d{2})", raw_entry)
                date_str = date_match.group(1) if date_match else "Unknown Date"
                
                # Extract Mood
                mood_match = re.search(r"\*\*Mood:\*\*\s*(.*)", raw_entry)
                mood = mood_match.group(1).strip() if mood_match else "Unknown"
                
                # Clean content for display (remove the header lines if desired, or keep them)
                # For now, we keep the raw entry as the content or just the body.
                # Let's keep the whole raw entry as it's formatted markdown.
                
                all_entries.append({
                    "filename": file,
                    "date": date_str,
                    "mood": mood,
                    "content": raw_entry.strip()
                })
                
        except Exception as e:
            print(f"Error reading {file}: {e}")
            
    return all_entries

def clear_chat():
    st.session_state.messages = []
    st.session_state.thread_id = str(uuid.uuid4())

# --- Sidebar ---

with st.sidebar:
    st.header("Controls")
    if st.button("Clear Chat", type="primary"):
        clear_chat()
        st.rerun()
        
    st.divider()
    
    st.header("ðŸ“Š Mood Analytics")
    entries = get_journal_entries()
    
    if entries:
        df = pd.DataFrame(entries)
        if not df.empty:
            # Mood Count Chart
            mood_counts = df['mood'].value_counts()
            st.bar_chart(mood_counts)
            
            # Recent Moods List
            st.subheader("Recent Moods")
            st.dataframe(df[['date', 'mood']], hide_index=True)
    else:
        st.info("No journal entries found yet.")

    st.divider()

    st.header("ðŸ“œ Past Entries")
    if entries:
        selected_entry = st.selectbox(
            "Select an entry to view:",
            options=entries,
            format_func=lambda x: f"{x['date']} - {x['mood']}"
        )
        
        if selected_entry:
            with st.expander("View Entry Content", expanded=False):
                st.markdown(selected_entry['content'])
    else:
        st.text("No entries to display.")

# --- Main Chat Interface ---

# Initialize session state
if "messages" not in st.session_state:
    st.session_state.messages = []
if "thread_id" not in st.session_state:
    st.session_state.thread_id = str(uuid.uuid4())

# Display chat messages
for message in st.session_state.messages:
    with st.chat_message(message["role"]):
        st.markdown(message["content"])

# Chat input
if prompt := st.chat_input("What's on your mind?"):
    # Add user message to state and display
    st.session_state.messages.append({"role": "user", "content": prompt})
    with st.chat_message("user"):
        st.markdown(prompt)

    # Generate response
    with st.chat_message("assistant"):
        message_placeholder = st.empty()
        full_response = ""
        
        # Config for the graph
        config = {"configurable": {"thread_id": st.session_state.thread_id}}
        
        try:
            # Stream from the graph
            events = ja.graph.stream(
                {"messages": [HumanMessage(content=prompt)]},
                config,
                stream_mode="values"
            )
            
            for event in events:
                if "messages" in event:
                    last_message = event["messages"][-1]
                    
                    # Only process AI messages
                    if last_message.type == "ai":
                        # Check for tool calls
                        if last_message.tool_calls:
                            message_placeholder.markdown("ðŸ’¾ *Saving journal entry...*")
                        else:
                            # Parse content using ja's helper
                            content = ja.parse_content(last_message.content)
                            full_response = content
                            message_placeholder.markdown(full_response)
            
            # Add assistant message to state if we got a response
            if full_response:
                st.session_state.messages.append({"role": "assistant", "content": full_response})
                # Rerun to update sidebar if a new entry was potentially saved (though tool call happens inside graph)
                # We might not want to rerun on every message, but if "Saving..." happened, it would be nice.
                # For now, we rely on manual refresh or next interaction.
                
        except Exception as e:
            st.error(f"An error occurred: {str(e)}")
